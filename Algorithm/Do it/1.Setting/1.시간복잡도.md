# 시간 복잡도

- 주어진 문제를 해결하기 위한 연산 횟수
- 일반적으로 파이썬 프로그램에서는 2000만 번 ~ 1억 번의 연산을 1초의 수행 시간으로 예측 가능

## 시간 복잡도 유형

- 빅-오메가 (Ω(n)): 최선일 때 (best case)의 연산 횟수를 나타낸 표기법
- 빅-세타 (θ(n)): 보통일 때 (average case)의 연산 횟수를 나타낸 표기법
- 빅-오 (O(n)): 최악일 때 (worst case)의 연산 횟수를 나타낸 표기법

```python
import random
findNumber = random.randrange(1, 101) # 1~100 사이 랜덤값 생성

for i in range(1,101):
  if i == findNumber:
    print(i)
    break
```

- 위 예제에서 빅-오메가 표기법의 시간 복잡도는 1번
- 빅-세타 표기법의 시간 복잡도는 N/2번
- 빅-오 표기법의 시간 복잡도는 N번

=> 당연히 코딩 테스트에서는 빅-오 표기법을 기준으로 수행시간을 계산하는 것이 좋음.

- 각각의 시간 복잡도는 데이터 크기 (N)의 증가에 따라 성능(수행 시간)이 다르다는 것을 확인할 수 있음

## 시간 복잡도 활용하기

ex. 시간 제한이 2초인 문제에서 해당 조건을 만족하려면 4000만 번 이하의 연산 횟수로 문제를 해결해야 함.
-> 문제에 주어진 시간 제한과 데이터 크기를 바탕으로 어떤 정렬 알고리즘을 사용해야 할 것인지를 판단할 수 있다.

### 연산 횟수 계산 방법

- 연산 횟수 = 알고리즘 시간 복잡도 n값에 데이터의 최대 크기를 대입하여 도출

### 알고리즘 적합성 평가

- 버블 정렬 = (1,000,000)\*\*2 = 1,000,000,000,000 > 40,000,000 -> 부적합 알고리즘
- 병합 정렬 = 1,000,000log2(1,000,000) = 약 20,000,000 < 40,000,000 -> 젹합 알고리즘

-> 병합 정렬은 약 2,000만 번의 연산 횟수로 답을 구할 수 있으므로 문제를 풀기에 적합한 알고리즘.

- 시간 복잡도는 작성한 코드의 비효율적인 로직을 개선하는 바탕으로 사용 가능

### 시간 복잡도 도출 기준

1. 상수는 시간 복잡도 계산에서 제외한다.
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.
